---
title: "Covid Vignette"
author: "Xavier Genelin"
date: "10/2/2021"
output: 
  github_document:
    toc: True
    html_preview: False
---

############## Current idea of what to do with this
Rework the live, total, and oneDay functions to allow the user to select a date range, province, and city/city code. Probably just the city because the code was a little odd. Not sure how it's choosing that. I should be able to print the list of options from the choices by using `toString(sort(unique(data$City)))`. Maybe make a function for that too, idk. 

Maybe having a function for live, total and oneday isn't the way to go?

The current issue is some of the urls don't work in the same order by just adding on things at the end. I'll have to go into the API site to see which one should be used for what the user might filter on. 

After that the visuals/EDA should be it for creating the vignette and then move on to the blog and stuff. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

This document is a vignette that'll show how we can retrieve data from an API and perform exploratory analysis. This will use the [Covid API](https://covid19api.com/). We will build our own functions that will collect data from the API and allow a user to interact with it by choosing different endpoints they can retrieve.

# Packages

To be able to interact with the API and manipulate the data we want to return, the following packages will need to be installed and used:

* `tidyverse`: this package will allow us to manipulate and visualize the data  
* `httr`: gives us a response object from the API url   
* `jsonlite`: allows us to interact with the API  
* `countrycode`: this lets us tie the country name to the continent which is defined by the World Bank Development Indicators. The Republic of Kosovo is the only one that seems to be missing the continent. This is located in Europe and will be added     

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(httr)
library(jsonlite)
library(countrycode)
```




urls for each type to refer back to 
```{r}
#day one: "https://api.covid19api.com/dayone/country/south-africa"
#by country: "https://api.covid19api.com/country/south-africa"
#
#
#
#
#
#
#
#
#
#
#
cities <- c("Wake", "Durham", "Johnston")

paste("Please select: ", paste(cities, collapse = ","), sep = " ")
```

```{r}
# Day one all status
getAPI <- GET("https://api.covid19api.com/dayone/country/south-africa/status/confirmed/live")

dat <- fromJSON(rawToChar(getAPI$content))

test1 <- as_tibble(dat)
test1
test1 %>% arrange(desc(Date))

test1$continent <- countrycode(test1$Country, origin = "country.name", destination = "continent")
```

```{r}
# day one live 
getAPI <- GET("https://api.covid19api.com/dayone/country/south-africa/status/deaths/live")

dat <- fromJSON(rawToChar(getAPI$content))

test2 <- as_tibble(dat)
test2 %>% arrange(desc(Date))
test2
```


# Functions

This will be used in each of the functions to get the data from the API. Just an example for easy copying
```{r}
getAPI <- GET("https://api.covid19api.com/all")

dat <- fromJSON(rawToChar(getAPI$content))

as_tibble(dat)
covidSummary("global")
```

## `covidSummary`

This first function gets access to the covid summary data and allows the user to choose either a global or country summary. The global summary will return one row with data on NewConfirmed, TotalConfirmed, NewDeaths, TotalDeaths, NewRecovered, and TotalRecovered along with the date that this data is from. The country data will show the same data for `r nrow(covidSummary("country"))` countries as well as their country name, country code, and slug. We're also adding in the continent based on the country. If the user writes in a continent while trying to access the global information, it will still return the global information. For both the global and country summaries, this function will create a new variable that calculates the total percent that have died from covid. 

```{r}
# The user can either choose a global summary or country

covidSummary <- function(type, continent = "all"){
  ### you can either select global or country to see the global summary or 
  # the summary by country
  getAPI <- GET("https://api.covid19api.com/summary")
  dat <- fromJSON(rawToChar(getAPI$content))
  
  # This lets the user type in capital letters for the type and continent without erroring it out
  type <- tolower(type)

  
  if(type == "global"){
    output <- as_tibble(dat$Global)
    
    output <- output %>% mutate(percentDeath = round(TotalDeaths / TotalConfirmed * 100, 2), Date = as.Date(Date))
    
  } else if(type == "country"){
    output <- as_tibble(dat$Countries)
    
    output <- output %>% select("Country", "CountryCode", "Slug", "NewConfirmed", 
                                "TotalConfirmed", "NewDeaths", "TotalDeaths", "NewRecovered", "TotalRecovered", "Date")
    
    output$Continent <- countrycode(output$Country, origin = "country.name", destination = "continent")
    
    output$Continent[is.na(output$Continent)] <- "Europe"
    continents <- unique(output$Continent)
    
    output <- output %>% select("Country", "NewConfirmed", "TotalConfirmed", "NewDeaths", "TotalDeaths", "NewRecovered", "TotalRecovered", "Date", "Continent") %>% mutate(percentDeath = round(TotalDeaths / TotalConfirmed * 100, 2), Date = as.Date(Date))
    
      if(continent != "all"){
        continent <- str_to_title(continent)
        output <- output %>% filter(Continent == continent)
      
        if(nrow(output) == 0){
          # If the user selects a continent that isn't in the data set, it provides a list to choose from
          stop(paste("Please select one of the following continents: ", paste(continents, collapse = ","), sep = " "))
        }
      }
  }
  


  return(output)
}
```

## `getCountry`

The next function will allow the user to either type out the country name, country code, or slug it will return the slug value. This is necessary because country filters need to be the slug, so the user can choose anything and not have later functions error out. So for example, if someone wanted to get data on the United States, they would either have to type in "United States of America", "united-states", "US", or "us".

```{r}
getCountry <- function(country, IDType){
  # This will return a tibble with the country name, the country name in lowercase
  # with dashes instead of spaces (slug), and the country code of length 2
  # For example, if we want the United States:
  # country: United States of America, slug: united-states, id: US
  getAPI <- GET("https://api.covid19api.com/countries")
  dat <- fromJSON(rawToChar(getAPI$content))
  data <- as_tibble(dat)
  
  # This lets the user type in with capital letters but won't error out the function
  IDtype <- tolower(IDType)
  
  if(IDType == "country"){
    output <- data %>% filter(Country == country) %>% select(Slug)
  } else if(IDType == "id"){
    output <- data %>% filter(ISO2 == toupper(country)) %>% select(Slug)
  } else if(IDType == "slug"){
    output <- data %>% filter(slug == country) %>% select(Slug)
  } else {
    stop("ERROR: Invalid IDType. Should be country, id, or slug")
  }
  
  if(nrow(output) == 0){
    stop("ERROR: Country not found. Check spelling and possible capitalization")
  }
  return(output)
}

```

## `getState`

This acts in a similar way to the `getCountry` function. Some of the APIs require us to filter down either by time or province after selecting the province. So if we wanted data on the United States, we may need to filter by one of those two things. If we wanted to see Wisconsin's data, that is easy to put into the url and get the data. But for states like West Virginia where there are more than one word in the state's name, this has to be the two letter abbreviation of the state. This function will let the user choose either option for the state if they need to filter down the United States data. There may be a similar issue with provinces in other countries, but there doesn't seem to be anything in R to account for that at this time. 

```{r}
getState <- function(state, type = "name"){
  states <- data.frame(abbreviation = state.abb, name = state.name)
  
  # removes any capitalization that the user may input
  type <- tolower(type)
  
  if(type == "name"){
    # This capitalizes the first letter of each word 
    # Prevents the filter from getting nothing if the user doesn't enter it properly
    state <- str_to_title(state)
    output <- states %>% filter(name == state) %>% select(abbreviation)
  } else{
    # Capitalizes each letter if the user doesn't to prevent it from returning nothing
    state <- toupper(state)
    output <- states %>% filter(abbreviation == state) %>% select(abbreviation)
  }
  
  return(output)
}
```



## `covidDetails`

This function will get data fromt he Day One API. The user will need to specify the county and IDType to be able to get the data, but then have the option to leave the other variables as their default value which will not filter the data any further. The options they have are the status, province, city, type and date range. The status will be 

```{r}
covidDetails <- function(country, IDType, status = "all", province = "all", city = "all",  type = "none"){
  # removes any upper case letters the user may input to prevent the API from not returning any data
  province <- tolower(province)
  status <- tolower(status)
  type <- tolower(type)
  
  if(type == "none"){
    main <- "https://api.covid19api.com/dayone/country/"
  } else if(type == "total"){
    main <- "https://api.covid19api.com/total/dayone/country/"
  }
  

  country <- getCountry(country, IDType)
  
  url <- paste0(main, country)

  
  # This adjusts the url to fit what the user inputs or doesn't input for the status and province
  if(province != "all" & status != "all"){
    url <- paste0(url, "/status/", status, "?province=", province)
  } else if(province != "all" & status == "all"){
    url <- paste0(url, "?province=", province)
  } else if(province == "all" & status != "all"){
    url <- paste0(url, "status/", status)
  }
  
  return(url)
}
  
```

```{r}
covidDetails("SA", "id")
```

```{r}
getAPI <- GET("https://api.covid19api.com/dayone/country/south-africa/live")
dat <- fromJSON(rawToChar(getAPI$content))
as_tibble(dat)
```


```{r}
dayOneTotal("AL", "id")
```

## `dayOneLive`

```{r}
dayOneLive <- function(country, IDType, status = "confirmed", province = "all"){
  main <- "https://api.covid19api.com/country/"
  country <- getCountry(country, IDType)
  
  url <- paste0(main, country, "/status/", status, "live")
  
  # puts the province input as all lower case letters
  province <- tolower(province)
  if(province != "all"){
    url <- paste0(url, "?province=", )
  }
}
```


Testing to see if this will work as an error for the total function

It works for this one!!!!
```{r}
getAPI <- GET("https://api.covid19api.com/country/united-states/status/confirmed/live?province=wi")
dat <- fromJSON(rawToChar(getAPI$content))
test <- as_tibble(dat)
test
```

```{r}
# Dane county in Wisconsin
getAPI <- GET("https://api.covid19api.com/country/united-states?province=wisconsin")
dat <- fromJSON(rawToChar(getAPI$content))
data <- as_tibble(dat)

data %>% filter(City == "Dane")
```

```{r}
#getAPI <- GET("https://api.covid19api.com/dayone/country/united-states?province=wisconsin")
#dat <- fromJSON(rawToChar(getAPI$content))
#data <- as_tibble(dat)
#data
county <- toString(sort(unique(data$City)))
print(paste("Please select one of the following:", county))
print(county)

teststring <- toString(county)
teststring
```


The `total` function collects data from the API 


########### add in a time filter to this 
```{r}
total <- function(country, IDType, status = "all") {
  # get the total covid numbers for a country by day
  # user has the option to get all numbers or just confirmed, recovered, or deaths
  # Find an easy way to get the date in here along with the other functions
  # Date needs to be added in after the country and case portions
  status <- tolower(status)
  
  if(status == "all"){
    main <- "https://api.covid19api.com/total/country/"
    country <- getCountry(country, IDType)
    url <- paste0(main, country)
    getAPI <- GET(url)
    dat <- fromJSON(rawToChar(getAPI$content))
    output <- as_tibble(dat)
    
    output <- output %>% mutate(Date = as.Date(Date))
    
  } else if(status != "all"){
    main <- "https://api.covid19api.com/total/country/"
    country <- getCountry(country, IDType)
    url <- paste0(main, country, "/status/", status)
    getAPI <- GET(url)
    dat <- fromJSON(rawToChar(getAPI$content))
    output <- as_tibble(dat)
    
    output <- output %>% mutate(Date = as.Date(Date))
  } 
  if(output[1,1] == ""){
    stop("ERROR: make sure case is either all, confirmed, recovered, or deaths")
  }
  return(output)
}

total(country= "US", IDType = "id", status = "Deaths")
```

## `live`

Live data for each country
```{r}
live <- function(country, IDType, case = "all", province = "all") {
  # get the total covid numbers for a country by day
  # user has the option to get all numbers or just confirmed, recovered, or deaths
  if(case == "all"){
    main <- "https://api.covid19api.com/live/country/"
    country <- getCountry(country, IDType)
    url <- paste0(main, country)
    getAPI <- GET(url)
    dat <- fromJSON(rawToChar(getAPI$content))
    output <- as_tibble(dat)
    
  } else if(case != "all"){
    main <- "https://api.covid19api.com/live/country/"
    country <- getCountry(country, IDType)
    url <- paste0(main, country, "/status/", case)
    getAPI <- GET(url)
    dat <- fromJSON(rawToChar(getAPI$content))
    output <- as_tibble(dat)
  } 
  # the country will be missing but it will still have a dataframe of more than 1 row if there's something wrong with the output
  # this will check to see if that error happened to let the user know
  if(output[1,1] == ""){
    stop("ERROR: make sure case is either all, confirmed, recovered, or deaths")
  }
  
  if(province != "all"){
    output <- output %>% filter(Province == province)
  }
  
  return(output)
}
```

```{r}
live(country = "US", IDType = "id", case = " all", province = "Wisconsin")

```


Day one data for each country
```{r}
dayOne <- function(country, IDType, case = "all", province = "all") {
  # get the total covid numbers for a country by day
  # user has the option to get all numbers or just confirmed, recovered, or deaths
  if(case == "all"){
    main <- "https://api.covid19api.com/dayone/country/"
    country <- getCountry(country, IDType)
    url <- paste0(main, country)
    getAPI <- GET(url)
    dat <- fromJSON(rawToChar(getAPI$content))
    output <- as_tibble(dat)
    
  } else if(case != "all"){
    main <- "https://api.covid19api.com/dayone/country/"
    country <- getCountry(country, IDType)
    url <- paste0(main, country, "/status/", case)
    getAPI <- GET(url)
    dat <- fromJSON(rawToChar(getAPI$content))
    output <- as_tibble(dat)
  } 
  if(output[1,1] == ""){
    stop("ERROR: make sure case is either all, confirmed, recovered, or deaths")
  }
  
  if(province != "all"){
    output <- output %>% filter(Province == province)
  }
  
  return(output)
}
```

```{r}
dayOne(country = "AU", IDType = "id", case = "deaths")
```

Create one final function that uses the other functions above to collect whatever data is needed
```{r}
covid <- function(func, ...){
  if(func == "total"){
    output <- total(...)
  } else if(func == "live"){
    output <- live(...)
  } else if(func == "dayOne"){
    output <- dayOne(...)
  } else if(func == "summary"){
    output <- covidSummary(...)
  } else {
    stop("ERROR: choose total, live, dayOne, or summary as function")
  }
  return(output)
}
```

```{r}
covid("summary", "country")

covid("live", "gb", "id", "confirmed") %>% arrange(Province, Date) #%>% filter(Province == "Wisconsin")
```

Trying to get the province since some countries like the united states won't allow for the whole thing to be brought in because it's too large.
```{r}
test <- GET("https://api.covid19api.com/dayone/country/united-states")
another <- fromJSON(rawToChar(test$content))
print(another)
```



# Data Exporation

Make a scatter plot of values for the country summary with continents in different colors or totals in bars. Maybe both
```{r}
regionData <- covidSummary("country")
regionData
ggplot(data = regionData, aes(x = NewDeaths, y = NewConfirmed)) + 
  geom_point(aes(color = Continent))
```

```{r}
ggplot(data = regionData, aes(x = Continent, y = NewConfirmed)) + 
  geom_bar(stat = "identity") +
  labs(title = "New Confirmed Cases by Continent")

ggplot(data = regionData, aes(x = Continent, y = TotalConfirmed)) + 
  geom_bar(stat = "identity") +
  labs(title = "Total Confirmed Cases by Continent")
```

Trying something quick. Plot the top 10-15 countires with the highest new confirmed or new deaths or something
```{r}
check <- regionData %>% arrange(desc(NewConfirmed)) %>% slice(1:15)

  ggplot(data = check, aes(x = Country, y = NewConfirmed)) + 
  geom_bar(stat = "identity") +
  labs(title = "Total Confirmed Cases by Continent")
```


